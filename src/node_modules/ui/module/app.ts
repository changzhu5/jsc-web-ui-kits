import BaseObject from "./base.object";
import * as $ from "jquery/dist/jquery.min.js";
import State from "./state";
import * as moment from "moment";
import CustomEvent from "./custom.event";
import BaseComponent from "ui/component/component";

declare let Promise;
declare let require;
/**
 * State Object Cache
 */
const states = new Map();
/**
 * Component Object Cache
 */
const map = new Map();
/**
 * Custom Component Class Defination
 */
const components = new Map();
/**
 * Custom Tag Defination
 */
const tags = new Map();
/**
 * Custom Attribute Defination
 */
const attributes = new Map();

export default class App extends BaseObject {
    public autoIncrementId = 1;
    /**
     * Config object across applications
     */
    protected value;
    /**
     * mmAlert component, display operational status
     */
    public alert;
    /**
     * mmAlert component, display confirmation
     */
    public cc;

    public themeBaseUrl;

    public vendorBaseUrl;

    public siteBaseUrl;

    public isReady;

    public hidden;

    public activeStateName;

    public prevStateName;

    public constructor() {
        super();
        this.isReady = false;
        this.value = null;
        this.themeBaseUrl = "";
        this.vendorBaseUrl = "";
    }

    public static events() {
        let events = super.events();
        events["ready"] = {
            description: "Before bootstrap"
        };
        events["config"] = {
            description: "After bootstrap"
        };
        events["unload"] = {
            description: "Page unload"
        };
        events["click"] = {
            description: "Page click"
        };
        events["document-visibility-change"] = {
            description: "Tab visible"
        };
        events["error"] = {
            description: "Global error event"
        };
        events["broadcast"] = {
            description: "For any purpose of events"
        }
        events["state-change"] = {
            descripton: "Before state change"
        };

        return events;
    }

    public getNextId() {
        return this.autoIncrementId++;
    }

    public bootstrap(): App {
        const app = this;
        app.trigger("config");
        //Init app state
        let hidden, visibilityChange;
        if (typeof document.hidden !== "undefined") { // Opera 12.10 and Firefox 18 and later support
            hidden = "hidden";
            visibilityChange = "visibilitychange";
        } else if (typeof document['msHidden'] !== "undefined") {
            hidden = "msHidden";
            visibilityChange = "msvisibilitychange";
        } else if (typeof document['webkitHidden'] !== "undefined") {
            hidden = "webkitHidden";
            visibilityChange = "webkitvisibilitychange";
        }
        app.hidden = document[hidden];
        function handleVisibilityChange() {
            app.hidden = document[hidden];
            app.trigger("document-visibility-change");    
        }

        if (typeof document.addEventListener === "undefined" || hidden === undefined) {
            console.log("Browser doesn't support the Page Visibility API.");
        } else {
            document.addEventListener(visibilityChange, handleVisibilityChange, false);
        }

        //Init theme base url
        if (this.value && this.value.themeBaseUrl !== undefined) {
            this.themeBaseUrl = this.value["themeBaseUrl"];
        }

        //Init site base url
        if (this.value && this.value.siteBaseUrl !== undefined) {
            this.siteBaseUrl = this.value.siteBaseUrl;
        }

        //Init vendor base url
        if (this.value && this.value.vendorBaseUrl !== undefined) {
            this.vendorBaseUrl = this.value["vendorBaseUrl"];
        }

        if (! this.option("states")) {
            this.option("states", [{
                name: 'default'
            }]);
        }
        if (! this.option("activeStateName")) {
            this.option("activeStateName", "default");
        }

        //Init app states
        for (const stateConfig of this.option("states")) {
            const state = new State(stateConfig);
            states.set(state.name, state);
        }
        this.activeStateName = this.option("activeStateName");

        //Init some window event handler
        window.onpopstate = function(e) {
            if (! e.state || e.state == null) {
                return;
            }
            if (e.state.name == null) {
                return;
            }
            app.prevStateName = app.activeStateName;
            app.activeStateName = e.state.name;
            states.get(e.state.name).run(states.get(app.prevStateName));
        }
        window.onbeforeunload = function() {
            app.trigger("unload");
        }

        //Set a notification component
        app.alert = app.create({
            name: "alert",
            type: "mmAlert",
            props: {
                label: "&nbsp;",
                asStatusBar: true,
                visible: false
            }
        }, $("body"));
        app.cc = app.create({
            name: "confirm",
            type: "mmModal",
            props: {
                visible: false
            }
        }, $("body"));

        //Init a place for homeless(ejected) components
        $('body').append('<div id="homeless" style="display: none"></div>');
        
        //Init body click
        $(document).ready(function() {
            $(this).on("click", function(e) {
                app.trigger("click", e);
            });
        });
        
        (<any>window).require.config({ paths: { 'vs': app.vendorBaseUrl + '/monaco/vs' }});
        (<any>window).MonacoEnvironment = {
            getWorkerUrl: function(workerId, label) {
                return app.siteBaseUrl ? app.siteBaseUrl + '/monaco-editor-worker-loader-proxy.js' : 'monaco-editor-worker-loader-proxy.js';
            }
        };
        (<any>window).require(['vs/editor/editor.main'], function() {
            app.isReady = true;
            app.trigger("ready");
            const state = states.get(app.activeStateName);
            history.pushState({
                name: state.name
            }, "", state.getUrl());
            state.trigger("ready");
        });

        return this;
    }

    public registerComponent(type: string, classFunc: Function): void {
        components.set(type, classFunc);
    }

    public getComponentDef(type: string) {
        return components.has(type) ? components.get(type) : "";
    }

    public registerAttr(name: string, func: Function) {
        attributes.set(name, func);
    }

    public getAttributeDef(type: string) {
        return attributes.has(type) ? attributes.get(type) : ""; 
    }

    public getAttributeDefs() {
        return attributes;
    }

    public registerTag(name: string, func: Function) {
        tags.set(name, func);
    }

    public getTagDef(type: string) {
        return tags.has(type) ? tags.get(type) : "";
    }

    public getTagDefs() {
        return tags;
    }

    public create(options, replaceWithDom = null) {
        if (typeof(options) === "string") {
            options = JSON.parse(options);
        }
        if (options.name === undefined || ! options.name) {
            options.name = "comp-" + this.getNextId();
        }
        if (options.type === undefined || ! options.type) {
            return false;
        }
        if (! this.getComponentDef(options.type)) {
            return false;
        }
        
        let name = options.name;
        let type = options.type;

        if (! this.getComponentDef(type)) {
            throw "Unable to create component for " + type;
        }
        
        if (this.component(name, type)) {
            return this.component(name, type);
        }
        let classDef = this.getComponentDef(type);
        let comp = new classDef({
            name: name,
            type: type,
            scope: options.scope ? options.scope : {},
            options: options.options ? options.options : {},
            props: options.props != null ? options.props : "",
            on: options.on != null ? options.on : "",
            appendTo: replaceWithDom ? replaceWithDom : $('#homeless')
        });
        
        this.setComp(comp);

        return comp;
    }
    /**
     * Deprecate soon
     * @param config 
     * @returns 
     */
    public define(config) {
        if (config.type === undefined) {
            throw "type is required for component definition";
        }
        if (config.parent === undefined) {
            throw "parent is required for component definition";
        }
        if (this.getComponentDef(config.type)) {
            throw config.type + " has been defined";
        }
        if (! this.getComponentDef(config.parent)) {
            throw "Unknown component type#" + config.parent;
        }
        
        let app = this;

        let def = function(options) {
            app.getComponentDef(config.parent).apply(this, [options]);
            if (app.isObject(config.on)) {
                for (let eventName in config.on) {
                    this.on(eventName, config.on[eventName]);
                }
            }
            if(app.isObject(config.set)) {
                for (let key in config.set) {
                    if (app.isFunction(config.set[key])) {
                        let method = "set" + key.charAt(0).toUpperCase() + key.substr(1);
                        this[method] = config.set[key];
                    }
                }
            }
            if(app.isObject(config.get)) {
                for (let key in config.get) {
                    if (app.isFunction(config.get[key])) {
                        let method = "get" + key.charAt(0).toUpperCase() + key.substr(1);
                        this[method] = config.get[key];
                    }
                }
            }
        }
        let parentDef = app.getComponentDef(config.parent);
        def.prototype= Object.create(parentDef.prototype);
        def.prototype.constructor = def;
        def.prototype.constructor.properties = function() {
            let props = app.getComponentDef(config.parent).properties();
            if (! app.isObject(config.props)) {
                return props;
            }
            for (let key in config.props) {
                props[key] = config.props[key];
            }

            return props;
        }
        def.prototype.constructor.getPropSchemas = function() {
            return app.getComponentDef(config.parent).getPropSchemas();
        }
        def.prototype.constructor.events = function() {
            let events = app.getComponentDef(config.parent).events();
            if (! app.isObject(config.events)) {
                return events;
            }
            for (let key in config.events) {
                events[key] = config.events[key];
            }

            return events;
        }
        def.prototype.constructor.methods = function() {
            let methods = app.getComponentDef(config.parent).methods();
            if (! app.isObject(config.methods)) {
                return methods;
            }
            for (let key in config.methods) {
                methods[key] = config.methods[key];
            }

            return methods;
        }
        def.prototype.constructor.template = function() {
            return config.template;
        }
        app.registerComponent(config.type, def);

        return def;
    }

    public component(name: string, type: string) {
        return this.getComp(name, type);
    }

    public ready(func: Function) {
        if (! this.isReady) {
            this.on('ready', func);
        } else {
            func();
        }
    }

    public config(func: Function) {
        if (! this.isReady) {
            this.on("config", func);
        }
    }

    public state(stateEventName: string, listener: Function) {
        const parts = stateEventName.split(".");
        const eventName = parts.pop();
        const stateName = parts.join(".");
        
        this.ready(function() {
            if (states.has(stateName)) {
                states.get(stateName).on(eventName, listener);
            }
        });
    }

    public route(name: string, query: object = null) {
        const state = states.get(name);

        if (! state) {
            throw `Unable to find state#${name}`;
        }

        state.setQuery(query);
       
        history.pushState({
            name: name
        }, "", state.getUrl());

        this.prevStateName = this.activeStateName;
        this.activeStateName = state.name;

        state.run(states.get(this.prevStateName));
    }

    public refreshState(query:object = null) {
        const state = states.get(this.activeStateName);
        if (query) {
            state.setQuery(query);
        }
        state.run();
    }

    public getActiveState() {
        return states.get(this.activeStateName);
    }

    public service(request) {
        const app = this;
        const serviceBaseUrl = this.option("serviceBaseUrl");
        let loader = null;

        let data = {
            name: request.name,
            params: request.data ? request.data : {}
        };

        delete request.name;
        delete request.params;

        return new Promise(function(resolve, reject) {
            const setting = {
                ...request,
                url: serviceBaseUrl,
                method: "POST",
                data: data,
                dataType: 'json',
                success: function(resp) {
                    resolve(resp);
                },
                error: function() {
                    app.error("Unable to talk to server");
                    reject();
                }
            };
            $.ajax(setting);
        });
    }

    public error(msg: string, timeout = 5000) {
        this.alert.props({
            label: "Warning",
            description: msg,
            visible: true
        }).apply();
        
        let app = this;
        if (timeout) {
            setTimeout(function() {
                app.alert.prop("visible", false);
            }, 10000);
        }
    }

    public success(msg: string, timeout = 5000) {
        this.alert.props({
            label: "Success",
            alert: "success",
            description: msg,
            visible: true
        }).apply();
        let app = this;
        if (timeout) {
            setTimeout(function() {
                app.alert.prop("visible", false);
            }, 10000);
        }
    }

    public confirm(config) {
        this.cc.props({
            label: config.title ? config.title : "Confirm",
            content: config.msg ? config.msg : "Are you sure?",
            visible: true
        }).apply();
        this.cc.onClick = function(action) {
            if (action === "ok") {
                let comp = this;
                config.yes.apply(comp);
                comp.prop("visible", false);
            }
            if (action === "cancel") {
                let comp = this;
                if (config.no !== undefined) {
                    config.no.apply(comp);
                }
                comp.prop("visible", false);
            }
        }
    }

    public getCompSelectOptions() {
        let options = [];

        components.forEach(function(value, key) {
            options.push({
                label: key,
                value: key
            });
        });
        let compareFunc = function(a, b) {
            return a.label.localeCompare(b.label);
        }
        options.sort(compareFunc);

        return options;
    }
    
    public setValue(val) {
        if (this.isObject(val) && ! this.value) {
            this.value = val;
        }
    }

    public getValue() {
        return this.value;
    }

    public option(key: string, val: any = 'undefined') {
        if (! this.value) {
            this.value = {};
        }
        if (val === undefined || val == 'undefined') {
            let parts = key.split("=>");
            let data = this.value;
            for (const p of parts) {
                if (data[p] != null) {
                    data = data[p];
                } else {
                    return "";
                }
            }
            return data;
        }
        this.value[key] = val;

        return this;
    }

    public data(name: string, callback: Function = null) {
        let appData = this.option("data");
        
        if (! appData) {
            return "";
        }

        if (appData[name] === undefined) {
            return "";
        }

        return callback ? callback(appData[name]) : appData[name];
    }

    public title(title: string) {
        if (title !== undefined) {
            $("title").text(title);
        } else {
            return $("title").text();
        }
    }

    public setComp(comp) {
        if (! map.has(comp.type)) {
            map.set(comp.type, {});
        }

        let collection = map.get(comp.type);
        if (! (comp instanceof BaseComponent)) {
            comp = this.create(comp);
        }

        if (collection[comp.name] === undefined) {
            collection[comp.name] = comp;
            map.set(comp.type, collection);
        }

        return this;
    }

    public getComp(name: string, type: string): any {
        if (! map.has(type)) {
            return false;
        }
        let collection = map.get(type);
        return collection[name] !== undefined ? collection[name] : false;
    }

    public removeComp(comp) {
        if (! map.has(comp.type)) {
            return this;
        }
        let collection = map.get(comp.type);
        delete collection[comp.name];
        return this;
    }

    public getStates() {
        return states;
    }

    public findOne(type: string) {
        if (map.has(type)) {
            const collection = map.get(type);
            const firstKey = Object.keys(collection)[0];
            return collection[firstKey];
        }
        return "";
    }

    public utcToLocal(date: string, sourceFormat: string = "YYYY-MM-DD HH:mm:ss", targetFormat: string = "YYYY-MM-DD HH:mm") {
        return moment(moment.utc(date, sourceFormat).toDate()).local().format(targetFormat);
    }

    public trigger(eventName: string, ...args: any[]) {
        if (eventName === "broadcast") {
            if (args.length !== 1) {
                throw "Invalid arguments for broadcast event";
            }
            const e = new CustomEvent(args[0]);
            super.trigger(eventName, e);
        } else {
            super.trigger(eventName, ...args);
        }
    }
}