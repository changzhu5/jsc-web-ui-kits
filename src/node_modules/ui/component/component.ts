import app from "ui/module/index";
import BaseObject from "ui/module/base.object";
import * as $ from "jquery/dist/jquery.min.js";
import * as Handlebars from "handlebars";
import { ComponentType, BaseComponentInterface, ScopeType, ElementType, PropertyType, MethodType, EventType} from "ui/type";

const handlebarTemplates = new Map();

export default class BaseComponent extends BaseObject implements BaseComponentInterface
{
    public name: string;

    public type: string;

    public element: ElementType;

    public parent: BaseComponent;
    
    public scope: ScopeType;

    public children: BaseComponent[];

    public options: object;

    public constructor(options: ComponentType) {
        super();
        
        this.name = options.name;
        this.type = options.type;
        this.children = [];
        this.options = options.options;
        
        this.initScope(options.scope ? options.scope : null);

        if (! handlebarTemplates.has(this.type)) {
            handlebarTemplates.set(this.type, Handlebars.compile(this.constructor['template']()));
        }
        this.element = $(`<div></div>`);
        this.element.appendTo(options['appendTo']);
        
        let props = this.getProperties();
        let propsOnApply = [];
        for (let propName  in props) {
            if (props[propName]?.priority <= 0) {
                propsOnApply.push(propName);
                continue;
            }
            if (props[propName].default !== undefined && options?.props[propName] === undefined && (props[propName].priority === undefined || props[propName].priority > 0)) {
                if (! options.props) {
                    options.props = {};
                }
                options.props[propName] = props[propName].default;
            }
        }

        this.on("dragover", function() {
            $(".mm-drag-over").removeClass("mm-drag-over");
        });

        this.on("drop", function() {
            $(".mm-drag-over").removeClass("mm-drag-over");
        });

        this.on("move", function(fromContainer, toContainer) {
            if (fromContainer.name != toContainer.name || fromContainer.type != toContainer.type) {
                fromContainer.eject(this);
            }
        });

        this.on("apply", function() {
            if (this.prop("width")) {
                this.element.css('width', this.prop("width"));
            }
            if (this.prop("height")) {
                this.element.css('height', this.prop("height"));
            }
        });

        if (options.on) {
            for (let eventName in options.on) {
                if (this.isFunction(options.on[eventName])) {
                    this.on(eventName, options.on[eventName]);
                }
            }
        }

        if (options.scope) {
            for (let k in options.scope) {
                if (k != "name" && k != "getValue") {
                    this.setScopeVal(k, options.scope[k]);
                }
            }
        }

        let afterProps = {};
        if (propsOnApply.length > 0) {
            propsOnApply.forEach(function(p) {
                if (options.props[p] !== undefined) {
                    afterProps[p] = options.props[p];
                    delete options.props[p];
                } else if (props[p].default !== undefined) {
                    afterProps[p] = props[p].default;
                    delete options.props[p];
                }
            });
        }
        
        if (options.props) {
            this.props(options.props).apply();
            if (Object.keys(afterProps).length > 0) {
                this.props(afterProps).apply();
            }
        } else {
            if (Object.keys(afterProps).length > 0) {
                this.props(afterProps).apply();
            } else {
                this.apply();
            }
        }
    }

    public static template(): string {
        return `<div class="{{class}}"></div>`;
    }

    public static properties(): {[key: string]: PropertyType} {
        return {
            class: {
                label: "Class",
                type: "mmTags"
            },
            draggable: {
                label: "Draggable",
                type: "mmCheckbox",
                default: false
            },
            dragHandler: {
                label:"Drag handler selector",
                type: "mmTextfield"
            },
            dropable: {
                label: "Dropable",
                type: "mmCheckbox",
                default: false
            },
            dropZone: {
                label:"Drag handler selector",
                type: "mmTextfield"
            },
            dropEffect: {
                label: "Drop effect",
                type: "mmDropdown",
                props: {
                    options: [
                        {
                            label: "Move",
                            value: "move"
                        },
                        {
                            label: "Copy",
                            value: "copy"
                        },
                        {
                            label: "Link",
                            value: "link"
                        }
                    ]
                },
                default: "move"
            },
            width: {
                label: "Width",
                type: "mmTextfield",
                default: ""
            },
            height: {
                label: "Height",
                type: "mmTextfield",
                default: ""
            }
        };
    }

    public static getPropSchemas() {
        let props = this.properties();
        let schemas = {};
        let getSchema = function(prop) {
            if (prop.type === undefined) {
                return false;
            }
            switch (prop.type) {
                case "mmCheckbox":
                    return {
                        type: "boolean"
                    };
                case "mmNumber":
                    return {
                        type: "number"
                    };
                case "mmDropdown":
                    let enums = [];
                    for (let i = 0; i < prop.props.options.length; i++) {
                        enums.push(prop.props.options[i].value);
                    }
                    return {
                        enum: enums
                    };
                case "mmTags": {
                    return {
                        type: "array",
                        items: {
                            type: "string"
                        }
                    };
                }
                case "mmRepeater":
                    let ps = {};
                    for (let k in prop.props.meta) {
                        let s = getSchema(prop.props.meta[k]);
                        if (s) {
                            ps[k] = s;
                        }
                    }
                    return {
                        type: "array",
                        items: {
                            type: "object",
                            properties: ps
                        }
                    };
                case "mmJsonEditor":
                    return {
                        type: ["array", "object"]
                    };
                case "mmComponent":
                    return {
                        $ref: "component.json"
                    }
                case "mmCodeEditor":
                    return {
                        type: "string"
                    };
                default:
                    return {
                        type: "string"
                    };
            }
        }
        for (let key in props) {
            if (props[key].schema !== undefined) {
                schemas[key] = props[key].schema;
            } else {
                let s = getSchema(props[key]);
                if (s) {
                    schemas[key] = s;
                }
            }
        }
        return schemas;
    }

    public static events(): {[key: string]: EventType} {
        return {
            dragover: {
                label: "Dragover",
                params: {
                    event: "event"
                }
            },
            drop: {
                label: "Drop",
                params: {
                    event: "event"
                }
            },
            move: {
                label: "Moved",
                params: {
                    event: "event"
                }
            },
            apply: {
                label: "Apply"
            }
        };
    }

    public setClass(classes) {
        if (this.isArray(classes)) {
            this.setScopeVal("class", classes.join(" "));
        } else {
            this.setScopeVal("class", classes);
        }
    }

    public getClass() {
        const classes = this.getScopeVal("class");
        if (! classes) {
            return "";
        }
        return classes.split(" ");
    }

    public setDraggable(bool) {
        bool = JSON.parse(bool);
        let comp = this;
        let element = this.element;
        if (bool) {
            element.attr('draggable', true);
            element.off('dragstart').on('dragstart', function(e) {
                let dragHandler = comp.prop("dragHandler");
                if (dragHandler && $(dragHandler + ":hover").length > 0) {
                    app.option('draggedComp', comp);
                    return;    
                }

                e.preventDefault();
                return;
            });
        } else {
            element.attr('draggable', false);
            element.off('dragstart');
        }
        

        this.setScopeVal('draggable', bool);
    }

    public setDropable(bool) {
        bool = JSON.parse(bool);
        let comp = this;
        let element = this.element;
        element.off("dragover").on("dragover", (e) => {
            let dropable = comp.prop("dropable");
            let dropzone = comp.prop("dropZone");
            if (! dropable || ! dropzone) {
                e.preventDefault();
                return;
            }
            let draggedComp = app.option('draggedComp');
            if (draggedComp.name == comp.name && draggedComp.type == comp.type) {
                e.preventDefault();
                return;
            }
            e.stopPropagation();
            e.originalEvent.dataTransfer.dropEffect = comp.prop("dropEffect");

            let index = comp.getDropZones(e.originalEvent);
            element.off("drop").on("drop", (e) => {
                e.stopPropagation();
                if (index > -1) {
                    //draggedComp.trigger("move", draggedComp.container, comp.container);
                    comp.trigger("drop", draggedComp, index);
                }
            });
            if (index > -1) {
                comp.trigger("dragover", draggedComp, index);
            }
        });

        this.setScopeVal("dropable", bool);
    }

    public getDropZones(e) {
        let dropzone = this.prop("dropZone");
        let dropzones = this.element.find(dropzone);
        let mouseX = e.pageX;
        let mouseY = e.pageY;

        let affectedZone = -1;
        dropzones['each']((index, ele) => {
            let offset = $(ele).offset();
            let w= $(ele).width();
            let h = $(ele).height();
            if (mouseX > offset.left && mouseX < (offset.left + w) && mouseY > offset.top && mouseY < (offset.top + h)) {
                affectedZone = index;
            }
        });

        return affectedZone;
    }

    public prop(key: string, val: any = null): any {
        let properties = this.getProperties();
        if (properties[key] === undefined) {
            throw "Undefined property - " + key;
        }
        if (val !== null) {
            let r = this.setProp(key, val);
            if (r !== false) {
                this.apply();
            }
            
            return this;
        } else {
            let value;
            let method = "get" + (key.charAt(0).toUpperCase() + key.slice(1));
            if (this[method] !== undefined) {
                return this[method].apply(this);
            } else {
                value = this.getScopeVal(key);
            }
            if (value === null) {
                return "";
            }
            if (this.isObject(value)) {
                return {...value}
            }
            return value;
        }
    }

    public props(config = null): any {
        let ps = this.getProperties();
        if (! config) {
            if (! ps) {
                return null;
            }
            let data = {};
            for (let name in ps) {
                if (name.charAt(0) == "$" || name.charAt(0) == "_") {
                    continue;
                }
                if (ps[name].type === undefined) {
                    continue;
                }
                data[name] = this.prop(name);
            }
            
            return {...data};
        } else {
            if (! this.isObject(config)) {
                return;
            }
            let order = [];
            let exclude = [];
            for (const [key, opt] of Object.entries(ps)) {
                if (opt.priority && opt.priority > 1) {
                    order.push(key);
                }
            }
            order.sort(function(a, b) {
                return ps[b].priority - ps[a].priority
            });
            if (order) {
                for (let i = 0; i < order.length; i++) {
                    if (config[order[i]] !== undefined) {
                        this.setProp(order[i], config[order[i]]);
                        exclude.push(order[i]);
                    }
                }
            }
            for (let key in config) {
                if (exclude.indexOf(key) < 0) {
                    this.setProp(key, config[key]);
                }
            }

            return this;
        }
    }

    public initScope(scope: any = null): void {
        let listeners = [];
        let comp = this;
        this.scope = {
            ...scope,
            name: comp.name,
            getOwner: function() {
                return comp;
            },
            getValue: function(key: string): any {
                let parts = key.split(".");
                let data = this;
                for (const p of parts) {
                    if (data[p] == null) {
                        return "";
                    }
                    data = data[p];
                }
    
                return data;
            },
            setValue: function(key: string, val: any) {
                let parts = key.split(".");
                let data = this;
                for (const p of parts) {
                    if (data[p] == null) {
                        return "";
                    }
                    data = data[p];
                }
                data = val;
            },
            watch: function(func, params: any = []) {
                listeners.push([func, params]);
                return this;
            },
            apply: function() {
                listeners.forEach(function(func) {
                    func[0].apply(this, func[1]);
                }, this);
            },

        }
    }

    protected setProp(key: string, val: any): BaseComponent | boolean {
        let properties = this.getProperties();
        if (properties[key] === undefined) {
            return false;
        }
        if (properties[key].editable !== undefined && ! properties[key].editable) {
            return false;
        }
        if (val !== null) {
            let method = "set" + (key.charAt(0).toUpperCase() + key.slice(1));
            if (this[method] !== undefined) {
                return this[method].apply(this, [val]);
            } else {
                if (properties[key].type != null && properties[key].type == "mmCheckbox") {
                    if (! val) {
                        val = false;
                    } else {
                        val = this.isNumber(val) ? val : JSON.parse(val);
                        if (val) {
                            val = true;
                        } else {
                            val = false;
                        }
                    }
                }
                this.setScopeVal(key, val);
            }
        }
    }

    public method(name: string, p1: any = null, p2: any = null, p3: any = null): any {
        let methods = this.getMethods();
        if (methods[name] === undefined) {
            throw "Undefined method - " + name;
        }
        let args = [];
        for (let i = 1; i < arguments.length; i++) {
            args.push(arguments[i]);
        }
        let result = methods[name].body.apply(this, args);
        if (result === undefined) {
            return this;
        }
        return result;
    }

    protected setScopeVal(key: string, value: any): void {
        this.scope[key] = value;
    }

    protected getScopeVal(key: string): any {
        if (this.scope[key] !== undefined) {
            return this.scope[key];
        }
        return null;
    }

    public getProperties(): {[key: string]: PropertyType} {
        return this.constructor['properties']();
    }

    public getMethods() {
        return this.constructor['methods']();
    }

    public replaceWith(comp: BaseComponent) {
        if (comp === this) {
            return;
        }
        if (! comp.element) {
            comp.element = $('<div></div>');
            this.element.replaceWith(comp.element);
            comp.apply();
        } else {
            this.element.replaceWith(comp.element);
        }
    }

    protected apply(): void {
        if (! this.element) {
            return;
        }
        if (this.children.length > 0) {
            this.children.forEach(function(c) {
                $("#homeless").append(c.element);
            });
        }
        let comp = this;
        let scope = this.getScope();
        let obj = this;
        let template = handlebarTemplates.get(this.type);
        let element = $(template(scope));
        this.element.replaceWith(element);
        this.element = element;
        this.element.attr("data-component-name", this.name);
        this.element.attr("data-component-type", this.type);
        this.element.data(this.type, this);
        //find & replace children
        this.children = [];
        this.element.find("mm-component").each(function() {
            const name = $(this).attr('name');
            const type = $(this).attr('type');
            let className = $(this).attr('class');
            const options = $(this).attr('options');
            if (options) {
                try {
                    let opt = scope.getValue(options);
                    if (comp.isFunction(opt)) {
                        opt = opt();
                    } else {
                        opt = comp.copy(opt);
                    }
                    let c = app.create(opt);
                    $(this).replaceWith(c.element);
                    comp.children.push(c);
                } catch (e) {
                    console.error("Unable to create component for scope." + options);
                }
                return;
            }
            if (app.component(name, type)) {
                if (className) {
                    className = app.component(name, type).prop("class") + " " + className;
                    app.component(name, type).prop("class", className);
                }
                $(this).replaceWith(app.component(name, type).element);
                comp.children.push(app.component(name, type));
            } else {
                console.warn(`Unable to find the component '${name}' of '${type}'`);
            }
        });

        //Parse custom tags
        let tags = app.getTagDefs();
        tags.forEach(function(def, tag) {
            element.find(tag).each(function() {
                def($(this), scope);
            });
        }, this);
        //parse custom attributes
        let attributes = app.getAttributeDefs();
        attributes.forEach(function(def, attr) {
            if (obj.isString(element.attr(attr))) {
                def(element, element.attr(attr), scope);
                element.removeAttr(attr);
            }
            element.find('[' + attr + ']').each(function() {
                def($(this), $(this).attr(attr), scope);
                $(this).removeAttr(attr);
            });
        }, this);

        this.trigger("apply");
    }

    public getScope(): ScopeType {
        return this.scope;
    }

    public destroy(): void {
        let comps = this.element.find("[data-component-name]");
        for (let i = comps.length - 1; i > -1; i--) {
            let comp = app.component(comps.eq(i).attr("data-component-name"), comps.eq(i).attr("data-component-type"));
            if (comp) {
                comp.destroy();
            }
        }
        this.element.remove();
        delete this.element;
        app.removeComp(this);
    }

    public trigger(eventName: string, ...args: any[]) {
        if (! this.element) {
            return;
        }
        return super.trigger(eventName, ...args);
    }

    public find(type: string): any {
        let elements = this.element.find("[data-component-type=" + type + "]");
        if (elements.length > 0) {
            let comps = [];
            for (let i = 0; i < elements.length; i++) {
                let id = elements.eq(i).attr("data-component-name");
                let comp = app.component(id, type)
                comps.push(comp);    
            }

            return comps;
        }
        return null;
    }

    public findOne(type: string, index: number = 0): BaseComponent | null {
        let comps = this.find(type);
        if (comps) {
            return comps[index];
        }
        return null;
    }

    public findAll() {
        let elements = this.element.find("[data-component-type]");
        if (elements.length > 0) {
            let comps = [];
            for (let i = 0; i < elements.length; i++) {
                let id = elements.eq(i).attr("data-component-name");
                let type = elements.eq(i).attr("data-component-type");
                let comp = app.component(id, type)
                comps.push(comp);    
            }

            return comps;
        }
        return null;
    }

    public closest(type: string): BaseComponent {
        let ele = this.element.closest("[data-component-type=" + type + "]");
        if (ele && ele.length > 0) {
            return app.component(ele.attr("data-component-name"), ele.attr("data-component-type"));
        }
    }

    public dom(posName: string = "element", index: number = 0, jDom: boolean = true): ElementType {
        if (posName == "element") {
            return this.element;
        }
        let jDoms = this.element.find("[position=" + posName + "]");
        if (jDoms.length <= 0) {
            return null;
        }
        if (jDom) {
            return jDoms.eq(index);
        }
        return jDoms.get(index);
    }
}